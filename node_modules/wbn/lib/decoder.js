import * as cborg from 'cborg';
import { encodedLength } from 'cborg/length';
import { B1, isApprovedVersion } from './constants.js';
const knownSections = [
    'critical',
    'index',
    'manifest',
    'primary',
    'responses',
    'signatures',
];
/** This class represents parsed Web Bundle. */
export class Bundle {
    version;
    b1PrimaryURL = null; // only valid in format version b1
    sections = {};
    responses = {}; // Offset-in-responses -> resp
    compatAdapter;
    constructor(buffer) {
        const wbn = asArray(cborg.decode(buffer, { useMaps: true }));
        let peekVersion = bytestringToString(wbn[1]).replace(/\0+$/, '');
        if (!isApprovedVersion(peekVersion)) {
            throw new Error('Unsupported web bundle version.');
        }
        this.compatAdapter = this.createCompatAdapter(peekVersion);
        if (wbn.length !== this.compatAdapter.wbnLength) {
            throw new Error(`Wrong toplevel structure ${peekVersion} ${wbn.length} ${this.compatAdapter.wbnLength}`);
        }
        const [magic, version, primaryURL, // null in format version b2
        sectionLengthsCBOR, sections, length,] = this.compatAdapter.destructureBundle(wbn);
        if (bytestringToString(magic) !== 'üåêüì¶') {
            throw new Error('Wrong magic');
        }
        const tempVersion = bytestringToString(version).replace(/\0+$/, ''); // Strip off the '\0' paddings.
        if (!isApprovedVersion(tempVersion)) {
            throw new Error('Unsupported web bundle version.');
        }
        this.version = tempVersion;
        if (primaryURL) {
            this.b1PrimaryURL = asString(primaryURL);
        }
        const sectionLengths = asArray(cborg.decode(asBytestring(sectionLengthsCBOR), { useMaps: true }));
        const sectionsArray = asArray(sections);
        if (sectionLengths.length !== sectionsArray.length * 2) {
            throw new Error("Number of elements in section-lengths and in sections don't match");
        }
        for (let i = 0; i < sectionsArray.length; i++) {
            this.sections[asString(sectionLengths[i * 2])] = sectionsArray[i];
        }
        if (this.sections['critical']) {
            for (const name of asArray(this.sections['critical'])) {
                if (!knownSections.includes(asString(name))) {
                    throw new Error(`unknown section ${name} is marked as critical`);
                }
            }
        }
        // The index section records (offset, length) of each response, but our
        // CBOR decoder doesn't preserve location information. So, recalculate
        // offset and length of each response here. This is inefficient, but works.
        const responses = asArray(this.sections['responses']);
        let offsetInResponses = encodedLength(responses.length);
        for (const resp of responses) {
            this.responses[offsetInResponses] = new Response(asArray(resp));
            offsetInResponses += encodedLength(resp);
        }
    }
    get manifestURL() {
        // the manifest section is not part of the b2 spec but it might have been defined anyway
        if (this.sections['manifest']) {
            return asString(this.sections['manifest']);
        }
        return null;
    }
    get urls() {
        return Array.from(this.indexSection.keys());
    }
    get primaryURL() {
        if (this.version === B1) {
            return this.b1PrimaryURL;
        }
        if (this.sections['primary']) {
            return asString(this.sections['primary']);
        }
        return null;
    }
    getResponse(url) {
        return this.compatAdapter.getResponse(url);
    }
    get indexSection() {
        return asMap(this.sections['index']);
    }
    // Behaviour that is specific to particular versions of the format.
    createCompatAdapter(formatVersion) {
        if (formatVersion === B1) {
            // format version b1
            return new (class {
                bundle;
                wbnLength = 6;
                constructor(bundle) {
                    this.bundle = bundle;
                }
                getResponse(url) {
                    const indexEntry = asArray(this.bundle.indexSection.get(url));
                    if (!indexEntry) {
                        throw new Error('No entry for ' + url);
                    }
                    const [variants, offset, length] = indexEntry;
                    if (asBytestring(variants).length !== 0) {
                        throw new Error('Variants are not supported');
                    }
                    if (indexEntry.length !== 3) {
                        throw new Error('Unexpected length of index entry for ' + url);
                    }
                    const resp = this.bundle.responses[asNumber(offset)];
                    if (!resp) {
                        throw new Error(`Response for ${url} is not found (broken index)`);
                    }
                    return resp;
                }
                destructureBundle(wbn) {
                    return [wbn[0], wbn[1], wbn[2], wbn[3], wbn[4], wbn[5]];
                }
            })(this);
        }
        else {
            // format version b2
            return new (class {
                bundle;
                wbnLength = 5;
                constructor(bundle) {
                    this.bundle = bundle;
                }
                getResponse(url) {
                    const indexEntry = asArray(this.bundle.indexSection.get(url));
                    if (!indexEntry) {
                        throw new Error('No entry for ' + url);
                    }
                    const [offset, length] = indexEntry;
                    if (indexEntry.length !== 2) {
                        throw new Error('Unexpected length of index entry for ' + url);
                    }
                    const resp = this.bundle.responses[asNumber(offset)];
                    if (!resp) {
                        throw new Error(`Response for ${url} is not found (broken index)`);
                    }
                    return resp;
                }
                destructureBundle(wbn) {
                    return [wbn[0], wbn[1], null, wbn[2], wbn[3], wbn[4]];
                }
            })(this);
        }
    }
}
/** This class represents an HTTP resource in Web Bundle. */
export class Response {
    status;
    headers;
    body;
    constructor(responsesSectionItem) {
        if (responsesSectionItem.length !== 2) {
            throw new Error('Wrong response structure');
        }
        const { status, headers } = decodeResponseMap(asBytestring(responsesSectionItem[0]));
        this.status = status;
        this.headers = headers;
        this.body = asBytestring(responsesSectionItem[1]);
    }
}
function decodeResponseMap(cbor) {
    const decoded = cborg.decode(cbor, { useMaps: true });
    if (!(decoded instanceof Map)) {
        throw new Error('Wrong header map structure');
    }
    let status = null;
    const headers = {};
    for (let [key, val] of decoded.entries()) {
        key = bytestringToString(key);
        val = bytestringToString(val);
        if (key === ':status') {
            status = Number(val);
        }
        else if (key.startsWith(':')) {
            throw new Error('Unknown psuedo header ' + key);
        }
        else {
            headers[key] = val;
        }
    }
    if (!status) {
        throw new Error('No :status in response header map');
    }
    return { status, headers };
}
// Type assertions and conversions for CBOR-decoded objects.
function asArray(x) {
    if (x instanceof Array) {
        return x;
    }
    throw new Error('Array expected, but got ' + typeof x);
}
function asMap(x) {
    if (x instanceof Map) {
        return x;
    }
    throw new Error('Map expected, but got ' + typeof x);
}
function asNumber(x) {
    if (typeof x === 'number') {
        return x;
    }
    throw new Error('Number expected, but got ' + typeof x);
}
function asString(x) {
    if (typeof x === 'string') {
        return x;
    }
    throw new Error('String expected, but got ' + typeof x);
}
function asBytestring(x) {
    if (x instanceof Uint8Array) {
        return x;
    }
    throw new Error('Bytestring expected, but got ' + typeof x);
}
function bytestringToString(bstr) {
    if (!(bstr instanceof Uint8Array)) {
        throw new Error('Bytestring expected');
    }
    return new TextDecoder('utf-8').decode(bstr);
}
