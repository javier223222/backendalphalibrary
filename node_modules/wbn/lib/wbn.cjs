"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/wbn.ts
var wbn_exports = {};
__export(wbn_exports, {
  Bundle: () => Bundle,
  BundleBuilder: () => BundleBuilder,
  Response: () => Response,
  combineHeadersForUrl: () => combineHeadersForUrl
});
module.exports = __toCommonJS(wbn_exports);

// src/decoder.ts
var cborg = __toESM(require("cborg"), 1);
var import_length = require("cborg/length");

// src/constants.ts
var B1 = "b1";
var B2 = "b2";
var DEFAULT_VERSION = B2;
var APPROVED_VERSIONS = [B1, B2];
function isApprovedVersion(param) {
  return APPROVED_VERSIONS.includes(param);
}

// src/decoder.ts
var knownSections = [
  "critical",
  "index",
  "manifest",
  "primary",
  "responses",
  "signatures"
];
var Bundle = class {
  version;
  b1PrimaryURL = null;
  sections = {};
  responses = {};
  compatAdapter;
  constructor(buffer) {
    const wbn = asArray(cborg.decode(buffer, { useMaps: true }));
    let peekVersion = bytestringToString(wbn[1]).replace(/\0+$/, "");
    if (!isApprovedVersion(peekVersion)) {
      throw new Error("Unsupported web bundle version.");
    }
    this.compatAdapter = this.createCompatAdapter(peekVersion);
    if (wbn.length !== this.compatAdapter.wbnLength) {
      throw new Error(`Wrong toplevel structure ${peekVersion} ${wbn.length} ${this.compatAdapter.wbnLength}`);
    }
    const [
      magic,
      version,
      primaryURL,
      sectionLengthsCBOR,
      sections,
      length
    ] = this.compatAdapter.destructureBundle(wbn);
    if (bytestringToString(magic) !== "\u{1F310}\u{1F4E6}") {
      throw new Error("Wrong magic");
    }
    const tempVersion = bytestringToString(version).replace(/\0+$/, "");
    if (!isApprovedVersion(tempVersion)) {
      throw new Error("Unsupported web bundle version.");
    }
    this.version = tempVersion;
    if (primaryURL) {
      this.b1PrimaryURL = asString(primaryURL);
    }
    const sectionLengths = asArray(cborg.decode(asBytestring(sectionLengthsCBOR), { useMaps: true }));
    const sectionsArray = asArray(sections);
    if (sectionLengths.length !== sectionsArray.length * 2) {
      throw new Error("Number of elements in section-lengths and in sections don't match");
    }
    for (let i = 0; i < sectionsArray.length; i++) {
      this.sections[asString(sectionLengths[i * 2])] = sectionsArray[i];
    }
    if (this.sections["critical"]) {
      for (const name of asArray(this.sections["critical"])) {
        if (!knownSections.includes(asString(name))) {
          throw new Error(`unknown section ${name} is marked as critical`);
        }
      }
    }
    const responses = asArray(this.sections["responses"]);
    let offsetInResponses = (0, import_length.encodedLength)(responses.length);
    for (const resp of responses) {
      this.responses[offsetInResponses] = new Response(asArray(resp));
      offsetInResponses += (0, import_length.encodedLength)(resp);
    }
  }
  get manifestURL() {
    if (this.sections["manifest"]) {
      return asString(this.sections["manifest"]);
    }
    return null;
  }
  get urls() {
    return Array.from(this.indexSection.keys());
  }
  get primaryURL() {
    if (this.version === B1) {
      return this.b1PrimaryURL;
    }
    if (this.sections["primary"]) {
      return asString(this.sections["primary"]);
    }
    return null;
  }
  getResponse(url) {
    return this.compatAdapter.getResponse(url);
  }
  get indexSection() {
    return asMap(this.sections["index"]);
  }
  createCompatAdapter(formatVersion) {
    if (formatVersion === B1) {
      return new class {
        constructor(bundle) {
          this.bundle = bundle;
        }
        wbnLength = 6;
        getResponse(url) {
          const indexEntry = asArray(this.bundle.indexSection.get(url));
          if (!indexEntry) {
            throw new Error("No entry for " + url);
          }
          const [variants, offset, length] = indexEntry;
          if (asBytestring(variants).length !== 0) {
            throw new Error("Variants are not supported");
          }
          if (indexEntry.length !== 3) {
            throw new Error("Unexpected length of index entry for " + url);
          }
          const resp = this.bundle.responses[asNumber(offset)];
          if (!resp) {
            throw new Error(`Response for ${url} is not found (broken index)`);
          }
          return resp;
        }
        destructureBundle(wbn) {
          return [wbn[0], wbn[1], wbn[2], wbn[3], wbn[4], wbn[5]];
        }
      }(this);
    } else {
      return new class {
        constructor(bundle) {
          this.bundle = bundle;
        }
        wbnLength = 5;
        getResponse(url) {
          const indexEntry = asArray(this.bundle.indexSection.get(url));
          if (!indexEntry) {
            throw new Error("No entry for " + url);
          }
          const [offset, length] = indexEntry;
          if (indexEntry.length !== 2) {
            throw new Error("Unexpected length of index entry for " + url);
          }
          const resp = this.bundle.responses[asNumber(offset)];
          if (!resp) {
            throw new Error(`Response for ${url} is not found (broken index)`);
          }
          return resp;
        }
        destructureBundle(wbn) {
          return [wbn[0], wbn[1], null, wbn[2], wbn[3], wbn[4]];
        }
      }(this);
    }
  }
};
var Response = class {
  status;
  headers;
  body;
  constructor(responsesSectionItem) {
    if (responsesSectionItem.length !== 2) {
      throw new Error("Wrong response structure");
    }
    const { status, headers } = decodeResponseMap(asBytestring(responsesSectionItem[0]));
    this.status = status;
    this.headers = headers;
    this.body = asBytestring(responsesSectionItem[1]);
  }
};
function decodeResponseMap(cbor) {
  const decoded = cborg.decode(cbor, { useMaps: true });
  if (!(decoded instanceof Map)) {
    throw new Error("Wrong header map structure");
  }
  let status = null;
  const headers = {};
  for (let [key, val] of decoded.entries()) {
    key = bytestringToString(key);
    val = bytestringToString(val);
    if (key === ":status") {
      status = Number(val);
    } else if (key.startsWith(":")) {
      throw new Error("Unknown psuedo header " + key);
    } else {
      headers[key] = val;
    }
  }
  if (!status) {
    throw new Error("No :status in response header map");
  }
  return { status, headers };
}
function asArray(x) {
  if (x instanceof Array) {
    return x;
  }
  throw new Error("Array expected, but got " + typeof x);
}
function asMap(x) {
  if (x instanceof Map) {
    return x;
  }
  throw new Error("Map expected, but got " + typeof x);
}
function asNumber(x) {
  if (typeof x === "number") {
    return x;
  }
  throw new Error("Number expected, but got " + typeof x);
}
function asString(x) {
  if (typeof x === "string") {
    return x;
  }
  throw new Error("String expected, but got " + typeof x);
}
function asBytestring(x) {
  if (x instanceof Uint8Array) {
    return x;
  }
  throw new Error("Bytestring expected, but got " + typeof x);
}
function bytestringToString(bstr) {
  if (!(bstr instanceof Uint8Array)) {
    throw new Error("Bytestring expected");
  }
  return new TextDecoder("utf-8").decode(bstr);
}

// src/encoder.ts
var cborg2 = __toESM(require("cborg"), 1);
var import_length2 = require("cborg/length");
var BundleBuilder = class {
  sectionLengths = [];
  sections = [];
  responses = [];
  currentResponsesOffset = 0;
  compatAdapter;
  constructor(formatVersion = DEFAULT_VERSION) {
    if (!isApprovedVersion(formatVersion)) {
      throw new Error(`Invalid webbundle format version`);
    }
    this.compatAdapter = this.createCompatAdapter(formatVersion);
  }
  createBundle() {
    this.compatAdapter.onCreateBundle();
    this.addSection("index", this.fixupIndex());
    this.addSection("responses", this.responses);
    const wbn = cborg2.encode(this.createTopLevel());
    const view = new DataView(wbn.buffer, wbn.byteOffset + wbn.length - 8);
    view.setUint32(0, Math.floor(wbn.length / 4294967296));
    view.setUint32(4, wbn.length & 4294967295);
    return wbn;
  }
  addExchange(url, status, headers, payload) {
    validateExchangeURL(url);
    if (typeof payload === "string") {
      payload = byteString(payload);
    }
    this.addIndexEntry(url, this.addResponse(new HeaderMap(status, headers), payload));
    return this;
  }
  setPrimaryURL(url) {
    return this.compatAdapter.setPrimaryURL(url);
  }
  setManifestURL(url) {
    return this.compatAdapter.setManifestURL(url);
  }
  addSection(name, content) {
    if (this.sectionLengths.some((s) => s.name === name)) {
      throw new Error("Duplicated section: " + name);
    }
    let length = (0, import_length2.encodedLength)(content);
    this.sectionLengths.push({ name, length });
    this.sections.push(content);
  }
  addResponse(headerMap, payload) {
    if (payload.length > 0 && !headerMap.has("content-type")) {
      throw new Error("Non-empty exchange must have Content-Type header");
    }
    const response = [headerMap.toCBOR(), payload];
    this.responses.push(response);
    return (0, import_length2.encodedLength)(response);
  }
  addIndexEntry(url, responseLength) {
    this.compatAdapter.setIndexEntry(url, responseLength);
    this.currentResponsesOffset += responseLength;
  }
  fixupIndex() {
    const responsesHeaderSize = (0, import_length2.encodedLength)(this.responses.length);
    return this.compatAdapter.updateIndexValues(responsesHeaderSize);
  }
  createTopLevel() {
    return this.compatAdapter.createTopLevel();
  }
  get formatVersion() {
    return this.compatAdapter.formatVersion;
  }
  createCompatAdapter(formatVersion) {
    if (formatVersion === B1) {
      return new class {
        constructor(bundleBuilder) {
          this.bundleBuilder = bundleBuilder;
        }
        formatVersion = B1;
        index = /* @__PURE__ */ new Map();
        primaryURL = null;
        onCreateBundle() {
          if (this.primaryURL === null) {
            throw new Error("Primary URL is not set");
          }
          if (!this.index.has(this.primaryURL)) {
            throw new Error(`Exchange for primary URL (${this.primaryURL}) does not exist`);
          }
        }
        setPrimaryURL(url) {
          if (this.primaryURL !== null) {
            throw new Error("Primary URL is already set");
          }
          validateExchangeURL(url);
          this.primaryURL = url;
          return this.bundleBuilder;
        }
        setManifestURL(url) {
          validateExchangeURL(url);
          this.bundleBuilder.addSection("manifest", url);
          return this.bundleBuilder;
        }
        setIndexEntry(url, responseLength) {
          this.index.set(url, [
            new Uint8Array(0),
            this.bundleBuilder.currentResponsesOffset,
            responseLength
          ]);
        }
        updateIndexValues(responsesHeaderSize) {
          for (const value of this.index.values()) {
            value[1] += responsesHeaderSize;
          }
          return this.index;
        }
        createTopLevel() {
          const sectionLengths = [];
          for (const s of this.bundleBuilder.sectionLengths) {
            sectionLengths.push(s.name, s.length);
          }
          return [
            byteString("\u{1F310}\u{1F4E6}"),
            byteString(`${formatVersion}\0\0`),
            this.primaryURL,
            cborg2.encode(sectionLengths),
            this.bundleBuilder.sections,
            new Uint8Array(8)
          ];
        }
      }(this);
    } else {
      return new class {
        constructor(bundleBuilder) {
          this.bundleBuilder = bundleBuilder;
        }
        formatVersion = B2;
        index = /* @__PURE__ */ new Map();
        onCreateBundle() {
        }
        setPrimaryURL(url) {
          validateExchangeURL(url);
          this.bundleBuilder.addSection("primary", url);
          return this.bundleBuilder;
        }
        setManifestURL(url) {
          throw new Error("setManifestURL(): wrong format version");
        }
        setIndexEntry(url, responseLength) {
          this.index.set(url, [
            this.bundleBuilder.currentResponsesOffset,
            responseLength
          ]);
        }
        updateIndexValues(responsesHeaderSize) {
          for (const value of this.index.values()) {
            value[0] += responsesHeaderSize;
          }
          return this.index;
        }
        createTopLevel() {
          const sectionLengths = [];
          for (const s of this.bundleBuilder.sectionLengths) {
            sectionLengths.push(s.name, s.length);
          }
          return [
            byteString("\u{1F310}\u{1F4E6}"),
            byteString(`${formatVersion}\0\0`),
            cborg2.encode(sectionLengths),
            this.bundleBuilder.sections,
            new Uint8Array(8)
          ];
        }
      }(this);
    }
  }
};
var HeaderMap = class extends Map {
  constructor(status, headers) {
    super();
    if (status < 100 || status > 999) {
      throw new Error("Invalid status code");
    }
    this.set(":status", status.toString());
    for (const key of Object.keys(headers)) {
      this.set(key.toLowerCase(), headers[key]);
    }
  }
  toCBOR() {
    const m = /* @__PURE__ */ new Map();
    for (const [key, value] of this.entries()) {
      m.set(byteString(key), byteString(value));
    }
    return cborg2.encode(m);
  }
};
function validateExchangeURL(urlString) {
  const url = new URL(urlString, "https://webbundle.example/");
  if (url.username !== "" || url.password !== "") {
    throw new Error("Exchange URL must not have credentials: " + urlString);
  }
  if (url.hash !== "") {
    throw new Error("Exchange URL must not have a hash: " + urlString);
  }
}
function byteString(s) {
  return new TextEncoder().encode(s);
}
function isHeaders(obj) {
  if (typeof obj !== "object") {
    return false;
  }
  for (const value of Object.values(obj)) {
    if (typeof value !== "string") {
      return false;
    }
  }
  return true;
}
function combineHeadersForUrl(headers, overrideHeadersOption, url) {
  if (!overrideHeadersOption)
    return headers;
  const headersForUrl = typeof overrideHeadersOption == "function" ? overrideHeadersOption(url) : overrideHeadersOption;
  if (!isHeaders(headersForUrl)) {
    throw new Error("Malformatted override headers: They should be an object of strings.");
  }
  return { ...headers, ...headersForUrl };
}
